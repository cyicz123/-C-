# 第九次实验报告
## 第九次实验内容
![第九次实验内](http://photo.cyicz123.com/Fk2aZijdlq2cSGShdSP4Q345ukXV)
## 第一题实验结果截图
![9_1](http://photo.cyicz123.com/FjtZd9WeG0zbyy2dwVf0nv4R0ax0)
可以看出在构造函数中外部对象的构造函数先工作，然后是内部构造函数。在析构函数中则正好相反。

## 第二题实验结果截图
![9_21](http://photo.cyicz123.com/FonOHXSwCgDPCq89b1Y7aJ1Sc_-a)
如果对象成员不含指针等变量，就可以用缺省的拷贝构造函数，利用系统将所有的成员变量赋值给新的成员变量。
但是如果对象成员含有指针变量，如果用默认的拷贝构造函数就会将指针指向的内存空间赋值给新的成员变量，于是这两个对象的成员指针就有了联系，无论对其中任何一个对象的指针内容修改都会影响到另一个对象造成问题。
并且如果析构函数删除指针的内存空间，那另一个对象的指针指向的空间同样会被删除，从而造成指针悬挂，当另一个对象析构时会对同一片已经释放的指针重新删除，从而出现内存泄漏。
![9_22](http://photo.cyicz123.com/Fh3qvAZqIRBhtZUDfKhmlltMEXmx)
### 拷贝构造函数起作用的三种情况：
1. 当用一个对象去初始化同类的另一个对象时；
2. 如果某个函数的一个参数是类A的对象，那么该函数被调用时会触发类A拷贝构造函数；
3. 如果某个函数的返回值是类A的对象时，那么该函数被调用然后返回值时，会触发类A拷贝构造函数；